# Генератор шаблонов UI форм

Создает шаблоны для генерации UI форм приложений. Сами формы генерируются по шаблонам с применением различных технологий
с помощью вспомогательных сервисов:

- delphi-gui-generator
- guigenerator
- javafx-gui-generator
- web-gui-generator
- wpf-gui-generator

Сгенерированные UI формы сразу имеют разметку и могут быть использованы в датасетах для обучения нейросетей.

## Архитектура программы

Программа состоит из следующих основных компонентов:

1. **Конфигурация** - JSON файлы, описывающие:
   - Виджеты и их свойства
   - Правила композиции
   - Ограничения на структуру
   - Стили оформления

2. **Генератор** - ядро программы, которое:
   - Создает случайные деревья виджетов
   - Проверяет соблюдение правил композиции
   - Учитывает вероятности и ограничения
   - Сохраняет результат в JSON

3. **Интерфейс командной строки** - позволяет:
   - Задавать количество генерируемых деревьев
   - Указывать каталоги для конфигурации и вывода
   - Получать справку по использованию

## Запуск скрипта для генерации деревьев

1. Загрузить скрипт
2. Перейти в директорию скрипта
  ```bash
  cd tree-gui-generator
  ```
3. Запустить скрипт 
  ```bash
  treegen.py 1000 --otp ../trees/
  ```
### Пример использования

1. Создать 1000 деревьев с настройками по умолчанию:
```bash
treegen.py 1000
```

2. Создать 500 деревьев с пользовательской конфигурацией:
```bash
treegen.py 500 --conf ./my_configs/
```

3. Создать 200 деревьев и сохранить в указанную директорию:
```bash
treegen.py 200 --otp ./output_trees/
```

4. Получить справку по параметрам:
```bash
treegen.py -h
```

### Параметры командной строки

`treegen.py [-h] [--conf CONF] [--otp OTP] ntrees`
  
Обязательные параметры:

- `ntrees` количество генерируемых деревьев.
    
Опциональные параметры:

- `-h`    справка;
- `--conf` после этого параметра указывается путь до директории с файлами-описаниями деревьев. 
По умлочанию папка `resources/configs/cut_configs/__current__almost_ok` в директории скрипта;
- `--otp` после этого параметра указывается путь до директории куда будут сохранены сгенерированные
        деревья. По умолчанию папка `resources/generated_trees` в директории скрипта.
    
## Стурктура дерева

Дерево описывается (конфигурируется) 4 файлами:

* `atomic_widget_descr.json` -- здесь хранится описание атомарных неделимых виджетов (таблицы, лейблы, кнопки)
* `comp_widget_descr.json` -- хранит описания композитных виджетов. Композитный виджет -- это виджет, состоящий из набора
  других виджетов: атомарных или контейнорв. Заданная структура всегда композита всегда выполняется. То есть, не бывает
  такого, что какой-то из виджетов описанных как часть композита отсутствует. Например, композит FormItem состоит из
  виджетов label и edit. Они не генерируются случайно, а заданы как часть FormItem.

* `cont_widget_descr.json` -- хранит описания контейнеров -- виджеты которые хранят другие виджеты, но не в строго
  фиксированной структуре как композиты, наличие виджетов, их порядок и расположение могут различаться.

* `tree_descr.json` -- хранит параметры построения дерева.

И отдельно стоит файл `widget_styles.json`, который хранит описания стилей оформления виджетов.

#### atomic_widget_descr.json

Пример описания атомарного виджета:

```json
{
  "name": "Label",
  "prob": 0.0,
  "style": [
    "default_label"
  ]
}
```

- `name` -- имя виджета;
- `prob` -- некотое вероятность появление виджета в дереве (или точнее некий вес характеризующий частотность появления),
  его как отдельного объекта, не в рамках композита. Если prob опущен, то он по умолчанию равен 0;
- `style` -- хранит список возможных описаний стилей виджета, когда он встречается отдельно. Не обязательный параметр,
  может быть опущен;
- `solo` -- булевский параметр, говорящий о том, что виджет может встречаться только один раз в дереве. Если не указан, то
  `solo = false`.

#### cont_widget_descr.json

Пример описания контейнера:

```json
  {
  "name": "LWindow",
  "solo": true,
  "prob": 0.1,
  "direction": "v",
  "nrows": 3,
  "ncols": 3,
  "children": [
    "FormBox",
    "Table",
    "List",
    "TextArea",
    "TreeView",
    "StatusBar"
  ]
}
```

* `name, prob, solo` -- аналогичны атомарным видежтам
* `children` -- содержит именя виджетов, которые могуть быть детьми данного. Здесь могут быть как атомарные виджеты, так и
  композиты или другие контейнеры.

Любой контейнер мыслится как сетка состоящая из ячеек.

* `nrows` -- количество строк сетки
* `ncols` -- количество столбцов сетки

Если значение опущено, то соотвтественно количество строк или столбцов не ограничено.

* `direction` -- показывает как нужно заполнять сетку. Может принимать два значения `v` и `h`.
    * `v` (vertical) -- заполнение производится слева на право, сверху вниз, то есть сначала заполняются все колонки
      первой строки, затем все колонки второй строки и так далее.
    * `h` (horizontal) -- заполнение произовдится сверху вниз, слева на право, то есть сначала заполняются все строки
      первой колонки, затем все строки второй колонки и так далее.

Каждой ячейке соответствует виджет из детей контейнера.

#### comp_widget_descr.json

Пример описания композитного виджета

```json
{
  "name": "TopFormItem",
  "prob": 0.15,
  "nrows": 2,
  "ncols": 1,
  "content": [
    {
      "name": "Label",
      "style": [
        "default_label"
      ],
      "group": 0,
      "row": 0,
      "row_span": 1,
      "col": 0,
      "col_span": 1
    },
    {
      "name": "Edit",
      "style": [
        "default_edit"
      ],
      "group": 1,
      "prob": 0.16,
      "row": 1,
      "row_span": 1,
      "col": 0,
      "col_span": 1
    },
    {
      "name": "ComboBox",
      "style": [
        "default_combobox"
      ],
      "group": 1,
      "prob": 0.16,
      "row": 0,
      "col": 1
    }
  ]
}
```

- `name, nrows, ncols` -- аналогичны предыдущему описанию.
- `content` -- содержит виджеты составляющие композит. В их параметрах присутствуют координаты расположения (row, col) и
  сколько ячеек занимает
  (row_span, col_span), если row_span и col_span опущены, то они равны 1.
    - Параметр group означает какой группе принадлежат виджеты. Например, в данном примере label принадлежит группе 0, а
      edit и combobox принадлежит группе 1. Причем edit и combobox распололожены в одной и той же строке-столбце. Если
      виджеты принадлежат одной группе, то при генерации композита в дереве случайным образом, в соответствтвии с весами
      из параметра prob, выбирается один из виджетов группы. Если prob опущен, то он по умолчанию равен 0
- `style` -- задает стили оформления виджетов. Набор стилей для композитов отличаются от стилей для одних и тех же имен
  атомарных виджетов

#### tree_descr.json

Содержит параметры генерации дерева.

```json
{
  "root": "Window",
  "min_nwidgets": 10,
  "max_nwidgets": 35
}
```

- `root` -- корневой виджет
- `min_nwidgets` -- минимальное количество виджетов в дереве.
- `max_nwidgets` -- максимальное количество виджетов в дереве.

Значение могут быть не точным, но ориентировочно очерчивают границы.

#### widget_styles.json

Задают стили оформления виджетов. Пример:

```json
{
  "name": "labelstyle",
  "widget": "Label",
  "props": {
    "font": "Arial",
    "size": 12,
    "color": "#000000"
  }
}
```

* `name` -- уникальное имя стиля
* `widget` -- имя виджета, к которому применяется стиль
* `props` -- словарь свойств стиля, где:
  - ключ - название свойства (например, "font", "color")
  - значение - параметр стиля (например, "Arial", "#000000")

Стили могут использоваться:
1. В атомарных виджетах для задания внешнего вида
2. В композитных виджетах для стилизации их компонентов
3. При рендеринге UI для применения визуальных свойств

## Формат выходных данных

Каждое сгенерированное дерево сохраняется в отдельный JSON файл со следующей структурой:

```json
{
  "root": {
    "name": "Window",
    "children": [
      {
        "name": "FormBox",
        "children": [
          {
            "name": "Label",
            "children": []
          },
          {
            "name": "Edit",
            "children": []
          }
        ]
      }
    ]
  }
}
```
